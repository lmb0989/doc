import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-DJCjgs7r.js";const t={};function l(p,i){return n(),a("div",null,i[0]||(i[0]=[e(`<p>pinus核心提供了两种connector，sioconnector和hybridconnector。<a href="http://xn--sioconnectorsocket-zo22a19c9z2a328a.io" target="_blank" rel="noopener noreferrer">其中sioconnector基于socket.io</a>，使用json作为其通信格式，hybridconnector则用于tcp/websocket的通信，它底层使用的是二进制协议。虽然在sioconnector中，socket.io的实现很好，对于超时、握手等都做了处理，并且使用json作为通信格式，方便了协议的定制和修改，但同时也带来了较多的通讯冗余数据。hybridconnector则是使用了二进制版本通讯协议，同时提供了route字典压缩和protobuf压缩，提高带宽利用率，以满足诸如移动环境的需求，同时上层接口仍保持json格式的接口，对以前版本之前的代码不产生任何影响，保留兼容性。在本部分，主要介绍hybridconector实现的具体的通信协议。</p><p>pinus的二进制协议包含两层编码：package和message。message层主要实现route压缩和protobuf压缩，message层的编码结果将传递给package层。package层主要实现pinus应用基于二进制协议的握手过程，心跳和数据传输编码，package层的编码结果可以通过tcp，websocket等协议以二进制数据的形式进行传输。message层编码可选，也可替换成其他二进制编码格式，都不影响package层编码和发送。</p><p>Pinus协议层的结构如下图所示：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/data-tran.png" alt="PinusProtocol" tabindex="0" loading="lazy"><figcaption>PinusProtocol</figcaption></figure><h1 id="pinus-package" tabindex="-1"><a class="header-anchor" href="#pinus-package"><span>pinus package</span></a></h1><p>package协议主要用来封装在面向连接的二进制流的通讯协议（如：tcp）上的pinus数据包。package分为控制包和数据包两种类型。前者用来实现pinus应用层面的控制流程，包括客户端和服务器的握手，心跳和服务器主动断开连接的通知等控制信息。后者则是用来在客户端和服务器之间传输应用数据。</p><h4 id="package格式" tabindex="-1"><a class="header-anchor" href="#package格式"><span>package格式</span></a></h4><p>package分为header和body两部分。header描述package包的类型和包的长度，body则是需要传输的数据内容。具体格式如下：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/pinus-pack.png" alt="pinus package" tabindex="0" loading="lazy"><figcaption>pinus package</figcaption></figure><ul><li>type - package类型，1个byte，取值如下。 <ul><li>0x01: 客户端到服务器的握手请求以及服务器到客户端的握手响应</li><li>0x02: 客户端到服务器的握手ack</li><li>0x03: 心跳包</li><li>0x04: 数据包</li><li>0x05: 服务器主动断开连接通知</li></ul></li><li>length - body内容长度，3个byte的大端整数，因此最大的包长度为2^24个byte。</li><li>body - 二进制的传输内容。</li></ul><p>各个package类型的具体描述和控制流程如下。</p><h4 id="握手" tabindex="-1"><a class="header-anchor" href="#握手"><span>握手</span></a></h4><p>握手流程主要提供一个机会，让客户端和服务器在连接建立后，进行一些初始化的数据交换。交换的数据分为系统和用户两部分。系统部分为pinus框架所需信息，用户部分则是用户可以在具体应用中自定义的内容。</p><p>握手的内容为utf-8编码的json字符串（不压缩），通过body字段传输。</p><p>握手请求：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;sys&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;version&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;1.1.1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;type&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;js-websocket&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }, </span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;user&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  	// any customized request data</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>sys.version - 客户端的版本号。每个客户端SDK的每一个版本都有一个固定的版本号。在握手阶段客户端将该版本号上传给服务器，服务器可以由此来判断当前客户端是否合适与服务器通讯。</li><li>sys.type - 客户端的类型。可以通过客户端类型和版本号一起来确定客户端是否合适。</li></ul><p>握手响应：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;code&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, 			</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// response code</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;sys&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;heartbeat&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, 	</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// heartbeat interval in second</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;dict&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}, 		</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// route dictionary</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;protos&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}		</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// protobuf definition data</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }, </span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;user&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  	// any customized response data</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>code - 握手响应的状态码。目前的取值：200代表成功，500为处理用户自定义握手流程时失败，501为客户端版本号不符合要求。</li><li>sys.heartbeat - 可选，心跳时间间隔，单位为秒，没指定表示不需要心跳。</li><li>dict - 可选，route字段压缩的映射表，没指定表示没有字典压缩。</li><li>protos - 可选，protobuf压缩的数据定义，没有表示没有protobuf压缩。</li><li>user - 可选，用户自定义的握手数据，没有表示没有用户自定义的握手数据。</li></ul><p>握手的流程如下：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/pinus-handshake.png" alt="handshake" tabindex="0" loading="lazy"><figcaption>handshake</figcaption></figure><p>当底层连接建立后，客户端向服务器发起握手请求，并附带必要的数据。服务器检验握手数据后，返回握手响应。如果握手成功，客户端向服务器发送一个握手ack，握手阶段至此成功结束。</p><h4 id="心跳" tabindex="-1"><a class="header-anchor" href="#心跳"><span>心跳</span></a></h4><p>心跳包的length字段为0，body为空。</p><p>心跳的流程如下：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/pinus-heartbeat.png" alt="heartbeat" tabindex="0" loading="lazy"><figcaption>heartbeat</figcaption></figure><p>服务器可以配置心跳时间间隔。当握手结束后，客户端发起第一个心跳。服务器和客户端收到心跳包后，延迟心跳间隔的时间后再向对方发送一个心跳包。</p><p>心跳超时时间为2倍的心跳间隔时间。服务器检测到心跳超时并不会主动断开客户端的连接。客户端检测到心跳超时，可以根据策略选择是否要主动断开连接。</p><h4 id="数据" tabindex="-1"><a class="header-anchor" href="#数据"><span>数据</span></a></h4><p>数据包用来在客户端和服务器之间传输数据所用。数据包的body是由上层传下来的任意二进制数据，package层不会对body内容做任何处理。</p><h4 id="服务器主动断开" tabindex="-1"><a class="header-anchor" href="#服务器主动断开"><span>服务器主动断开</span></a></h4><p>当服务器主动断开客户端连接时（如：踢掉某个在线玩家），会先向客户端发送一个控制消息，然后再断开连接。客户端可以通过这个消息来判断是否是服务器主动断开连接的。</p><h1 id="pinus-message" tabindex="-1"><a class="header-anchor" href="#pinus-message"><span>pinus message</span></a></h1><p>message协议的主要作用是封装消息头，包括route和消息类型两部分，不同的消息类型有着不同的消息头，在消息头里面可能要打入message id(即requestId)和route信息。由于可能会有route压缩，而且对于服务端push的消息，message id为空，对于客户端请求的响应，route为空，因此message的头格式比较复杂。</p><p>消息头分为三部分，flag，message id，route。如下图所示：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/message-header.png" alt="Message Head" tabindex="0" loading="lazy"><figcaption>Message Head</figcaption></figure><p>从上图可以看出，pinus消息头是可变的，会根据具体的消息类型和内容而改变。其中：</p><ul><li>flag位是必须的，占用一个byte，它决定了后面的消息类型和内容的格式;</li><li>message id和route则是可选的。其中message id采用<a href="https://developers.google.com/protocol-buffers/docs/encoding#varints" target="_blank" rel="noopener noreferrer">varints 128变长编码</a>方式，根据值的大小，长度在0～5byte之间。route则根据消息类型以及内容的大小，长度在0～255byte之间。</li></ul><h3 id="标志位flag" tabindex="-1"><a class="header-anchor" href="#标志位flag"><span>标志位flag</span></a></h3><p>flag占用message头的第一个byte，其内容如下</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/message-flag.png" alt="flag" tabindex="0" loading="lazy"><figcaption>flag</figcaption></figure><p>现在只用到了其中的4个bit，这四个bit包括两部分，占用3个bit的message type字段和占用1个bit的route标识，其中：</p><ul><li>message type用来标识消息类型,范围为0～7，现在消息共有四类，request，notify，response，push，值的范围是0～3。不同的消息类型有着不同的消息内容，下面会有详细分析。</li><li>最后一位的route表示route是否压缩，影响route字段的长度。<br> 这两部分之间相互独立，互不影响。</li></ul><h3 id="消息类型" tabindex="-1"><a class="header-anchor" href="#消息类型"><span>消息类型</span></a></h3><p>不同类型的消息，对应不同消息头，消息类型通过flag字段的第2-4位来确定，其对应关系以及相应的消息头如下图：</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/message-type.png" alt="Message Head Content" tabindex="0" loading="lazy"><figcaption>Message Head Content</figcaption></figure><p>上面的 <strong>-</strong> 表示不影响消息类型的bit位。</p><h3 id="route压缩标志位" tabindex="-1"><a class="header-anchor" href="#route压缩标志位"><span>route压缩标志位</span></a></h3><p>route主要分为压缩和未压缩两种，由flag的最后一位（route压缩标志位）指定，当flag中的route标志为0时，表示未压缩的route，为1则表示是压缩route。route通过系统生成和用户自定义的字典进行压缩，具体内容见<a href="%E6%B6%88%E6%81%AF%E5%8E%8B%E7%BC%A9">pinus压缩协议</a>。route字段的编码会依赖flag的这一位，其格式如下图:</p><figure><img src="https://github.com/node-pinus/pinus/wiki/images/route-compre.png" alt="Message Type" tabindex="0" loading="lazy"><figcaption>Message Type</figcaption></figure><p>上图是不同的flag标志对应的route字段的内容：</p><ul><li>flag的最后一位为1时，后面跟的是一个uInt16表示的route字典编号，需要通过查询字典来获取route;</li><li>flag最后一位为0是，后面route则由一个uInt8的byte，用来表示route的字节长度。之后是通过utf8编码后的route字符串，其长度就是前面一位byte的uInt8的值，因此route的长度最大支持256B。</li></ul><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><p>在本部分，介绍了pinus提供的hybridconnector的线上协议，包括package层和message层。当用户使用hybridconnector的时候，可以根据这里提供的协议信息，在客户端可以依据此协议完成与服务端的通信。</p>`,55)]))}const h=s(t,[["render",l]]),c=JSON.parse('{"path":"/Book/NodeJS/Pinus/%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.html","title":"pinus package","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"标志位flag","slug":"标志位flag","link":"#标志位flag","children":[]},{"level":3,"title":"消息类型","slug":"消息类型","link":"#消息类型","children":[]},{"level":3,"title":"route压缩标志位","slug":"route压缩标志位","link":"#route压缩标志位","children":[]}],"git":{"createdTime":1733216180000,"updatedTime":1733216180000,"contributors":[{"name":"lmb0989","email":"1150274785@qq.com","commits":1}]},"readingTime":{"minutes":14.93,"words":2239},"filePathRelative":"Book/NodeJS/Pinus/协议格式.md","localizedDate":"2024年12月3日","excerpt":"<p>pinus核心提供了两种connector，sioconnector和hybridconnector。<a href=\\"http://xn--sioconnectorsocket-zo22a19c9z2a328a.io\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">其中sioconnector基于socket.io</a>，使用json作为其通信格式，hybridconnector则用于tcp/websocket的通信，它底层使用的是二进制协议。虽然在sioconnector中，socket.io的实现很好，对于超时、握手等都做了处理，并且使用json作为通信格式，方便了协议的定制和修改，但同时也带来了较多的通讯冗余数据。hybridconnector则是使用了二进制版本通讯协议，同时提供了route字典压缩和protobuf压缩，提高带宽利用率，以满足诸如移动环境的需求，同时上层接口仍保持json格式的接口，对以前版本之前的代码不产生任何影响，保留兼容性。在本部分，主要介绍hybridconector实现的具体的通信协议。</p>"}');export{h as comp,c as data};
